## Project: Kinematics Pick & Place
---


### Here I will consider the [rubric points](https://review.udacity.com/#!/rubrics/972/view) individually and describe how I addressed each point in my implementation.  

---
### Writeup / README

[inverse position]: ./misc_images/misc3.png

### Kinematic Analysis
#### 1. Using the DH parameter table you derived earlier, create individual transformation matrices about each joint. In addition, also generate a generalized homogeneous transform between base_link and gripper_link using only end-effector(gripper) pose.

The following is my derived DH parameter table:

Links | alpha(i-1) | a(i-1) | d(i-1) | theta(i)
--- | --- | --- | --- | ---
0->1 | 0 | 0 | 0.75 | q1
1->2 | - pi/2 | 0.35 | 0 | -pi/2 + q2
2->3 | 0 | 1.25 | 0 | q3 
3->4 | - pi/2 | -0.054 | 1.5 | q4 
4->5 | pi/2 | 0 | 0 | q5
5->6 | - pi/2 | 0 | 0 | q6
6->EE | 0 | 0 | 0.303 | 0

![kinematic configuration](https://imgur.com/sZQa2AO.png)

All values are derived from the URDF file that describes the physical measurements of the robotic arm. The link offset from X<sub>1</sub> to X<sub>0</sub> is 0.75m, which is the sum of 0.42 and 0.33, the offsets of joint2 and joint1 from their parents along the Z-axis of the world frame. The alpha values represent the twist angle between Z axes, and they are derived by noting the relative orientation of the axes as I placed them. In all cases, they are 90 degrees apart. Another value of note here is the q2 symbol for theta 2. This value must be offset by 90 degrees, since its zero configuration has the X axis of its frame already 90 degrees off-axis from the previous frame before it has even moved. Other parameters, such as a2, the link length from Z<sub>1</sub> to Z<sub>2</sub>, were pulled straight from the URDF configuration file where they are explicitly specified.  

#### 2. Decouple Inverse Kinematics problem into Inverse Position Kinematics and inverse Orientation Kinematics; doing so derive the equations to calculate all individual joint angles.

```
(Pdb) T0_1
Matrix([
[cos(q1), -sin(q1), 0,    0],
[sin(q1),  cos(q1), 0,    0],
[      0,        0, 1, 0.75],
[      0,        0, 0,    1]])
(Pdb) T1_2
Matrix([
[ cos(q2 - 0.5*pi), -sin(q2 - 0.5*pi), 0, 0.35],
[                0,                 0, 1,    0],
[-sin(q2 - 0.5*pi), -cos(q2 - 0.5*pi), 0,    0],
[                0,                 0, 0,    1]])
(Pdb) T2_3
Matrix([
[cos(q3), -sin(q3), 0, 1.25],
[sin(q3),  cos(q3), 0,    0],
[      0,        0, 1,    0],
[      0,        0, 0,    1]])
(Pdb) T3_4
Matrix([
[ cos(q4), -sin(q4), 0, -0.054],
[       0,        0, 1,    1.5],
[-sin(q4), -cos(q4), 0,      0],
[       0,        0, 0,      1]])
(Pdb) T4_5
Matrix([
[cos(q5), -sin(q5),  0, 0],
[      0,        0, -1, 0],
[sin(q5),  cos(q5),  0, 0],
[      0,        0,  0, 1]])
(Pdb) T5_6
Matrix([
[ cos(q6), -sin(q6), 0, 0],
[       0,        0, 1, 0],
[-sin(q6), -cos(q6), 0, 0],
[       0,        0, 0, 1]])
(Pdb) T6_EE
Matrix([
[1, 0, 0,     0],
[0, 1, 0,     0],
[0, 0, 1, 0.303],
[0, 0, 0,     1]])
```

I created these transforms by providing the DH parameters to a function that returned a sequence of four basic transformations, two rotations and two translations. A function that returns the transformation for this sequence as defined in the literature follows:
```
def tf_matrix(alpha, a, d, q):
    return Matrix([[          cos(q),           -sin(q),           0,             a],
		[sin(q)*cos(alpha), cos(q)*cos(alpha), -sin(alpha), -sin(alpha)*d],
		[sin(q)*sin(alpha), cos(q)*sin(alpha),  cos(alpha),  cos(alpha)*d],
		[                0,                 0,           0,             1]])

```

Finally, a full transform betwen the base_link and gripper_link is generated by multiplying the full set of the previous transforms:

```
(Pdb) T0_EE
Matrix([
[(((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*cos(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*sin(q5))*cos(q6) - ((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) - sin(q1)*cos(q4))*sin(q6), -(((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*cos(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*sin(q5))*sin(q6) - ((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) - sin(q1)*cos(q4))*cos(q6), -((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*sin(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*cos(q5), -0.303*((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*sin(q5) + 0.303*(-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*cos(q5) + 0.054*sin(q3)*sin(q2 - 0.5*pi)*cos(q1) - 1.5*sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - 1.5*sin(q2 - 0.5*pi)*cos(q1)*cos(q3) - 0.054*cos(q1)*cos(q3)*cos(q2 - 0.5*pi) + 1.25*cos(q1)*cos(q2 - 0.5*pi) + 0.35*cos(q1)],
[(((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*cos(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*sin(q5))*cos(q6) - ((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) + cos(q1)*cos(q4))*sin(q6), -(((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*cos(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*sin(q5))*sin(q6) - ((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) + cos(q1)*cos(q4))*cos(q6), -((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*sin(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*cos(q5), -0.303*((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*sin(q5) + 0.303*(-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*cos(q5) + 0.054*sin(q1)*sin(q3)*sin(q2 - 0.5*pi) - 1.5*sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - 1.5*sin(q1)*sin(q2 - 0.5*pi)*cos(q3) - 0.054*sin(q1)*cos(q3)*cos(q2 - 0.5*pi) + 1.25*sin(q1)*cos(q2 - 0.5*pi) + 0.35*sin(q1)],
[                                                                                         ((sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*sin(q5) + (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*cos(q4)*cos(q5))*cos(q6) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q4)*sin(q6),                                                                                          -((sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*sin(q5) + (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*cos(q4)*cos(q5))*sin(q6) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q4)*cos(q6),                                                       (sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*cos(q5) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q5)*cos(q4),                                                                                                       0.303*(sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*cos(q5) - 0.303*(-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q5)*cos(q4) + 1.5*sin(q3)*sin(q2 - 0.5*pi) + 0.054*sin(q3)*cos(q2 - 0.5*pi) + 0.054*sin(q2 - 0.5*pi)*cos(q3) - 1.25*sin(q2 - 0.5*pi) - 1.5*cos(q3)*cos(q2 - 0.5*pi) + 0.75],
[                                                                                                                                                                                                                                                                                                                 0,                                                                                                                                                                                                                                                                                                                   0,                                                                                                                                                                                            0,                                                                                                                                                                                                                                                                                                                                                                                                                       1]])

```

As instructed, I broke the inverse problem into two smaller problems, one an inverse position problem for the wrist center, and one an inverse orientation problem for the wrist itself.

I began by finding the wrist center. The wrist center was provided in the request, but it needed to be rotated to compensate for discrepancy between the DH parameters and the specifications in the URDF file. Two extrinsic rotations about the z and y axes were performed, and 0.303 meters were subtracted to account for the distrance from the gripper link to joint6 and the distance from joint6 to joint5, which is the wrist center.

![wrist center compensation](https://imgur.com/CC2FP29.png)

Next, I needed to compute the theta angles necessary to position the wrist center, which means angles 1-3. The first theta value is trivial, and can be found by using the arctan function on the x and y values of the wrist center.

Next, I followed the instructions in the walkthrough video to compute the sides and angles of a triangle that is formed between the wrist center and the DH frame corresponding to joint 2. The sides and angles are partly given by the URDF file, and partly derived using the law of cosines from trigonometry, which defines an equation that relates the sides of a triangle to the cosine of one of its angles. Then I deduced theta<sub>2</sub> and theta<sub>3</sub> using known angles from this triangle.  

![inverse position computation][inverse position]

Now, I had the wrist center position angles computed, but still required the angles defining its rotation. These were found by passing the newly discovered thetas 1-3 into the rotation matrix from frame 0 to 3. A rotation matrix from the base frame to the gripper was provided by gazebo. By multiplying the inverse of R<sub>0,3</sub> into the gripper rotation, we obtain the rotation matrix from frame 3 to 6, which will define the orientation of the gripper we are looking for.

### Project Implementation

#### 3. Fill in the `IK_server.py` file with properly commented python code for calculating Inverse Kinematics based on previously performed Kinematic Analysis. Your code must guide the robot to successfully complete 8/10 pick and place cycles. Briefly discuss the code you implemented and your results. 

This implementation follows the walkthrough video to compute inverse kinematics on the Kuka 210. I used sympy to perform symbolic matrix algebra to reduce computational overhead when possible. This code executes the task successfully, but it is rather slow. This code does not extract some repetitive processes that could have optimized for better performance. For example, transformation and rotation matrices could be saved to text files so that they don't need to be recomputed for every pass through the position trajectory of the arm. Using a library like numpy to squeeze out some more efficiency in matrix algebra might also help to speed things up. 



