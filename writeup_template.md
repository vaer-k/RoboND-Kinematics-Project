## Project: Kinematics Pick & Place
---


## [Rubric](https://review.udacity.com/#!/rubrics/972/view) Points
### Here I will consider the rubric points individually and describe how I addressed each point in my implementation.  

---
### Writeup / README

### Kinematic Analysis
#### 1. Using the DH parameter table you derived earlier, create individual transformation matrices about each joint. In addition, also generate a generalized homogeneous transform between base_link and gripper_link using only end-effector(gripper) pose.

The following is my derived DH parameter table:

Links | alpha(i-1) | a(i-1) | d(i-1) | theta(i)
--- | --- | --- | --- | ---
0->1 | 0 | 0 | 0.75 | q1
1->2 | - pi/2 | 0.35 | 0 | -pi/2 + q2
2->3 | 0 | 1.25 | 0 | q3 
3->4 | - pi/2 | -0.054 | 1.5 | q4 
4->5 | pi/2 | 0 | 0 | q5
5->6 | - pi/2 | 0 | 0 | q6
6->EE | 0 | 0 | 0.303 | 0

![kinematic configuration](https://imgur.com/a/vbh8Q)

All values are derived from the URDF file that describes the physical measurements of the robotic arm. The link offset from X<sub>1</sub> to X<sub>0</sub> is 0.75m, which is the sum of 0.42 and 0.33, the offsets of joint2 and joint1 from their parents along the Z-axis of the world frame. The alpha values represent the twist angle between Z axes, and they are derived by noting the relative orientation of the axes as I placed them. In all cases, they are 90 degrees apart. Another value of note here is the q2 symbol for theta 2. This value must be offset by 90 degrees, since its zero configuration has the X axis of its frame already 90 degrees off-axis from the previous frame before it has even moved. Other parameters, such as a2, the link length from Z<sub>1</sub> to Z<sub>2</sub>, were pulled straight from the URDF configuration file where they are explicitly specified.  

#### 2. Decouple Inverse Kinematics problem into Inverse Position Kinematics and inverse Orientation Kinematics; doing so derive the equations to calculate all individual joint angles.

```
(Pdb) T0_1
Matrix([
[cos(q1), -sin(q1), 0,    0],
[sin(q1),  cos(q1), 0,    0],
[      0,        0, 1, 0.75],
[      0,        0, 0,    1]])
(Pdb) T1_2
Matrix([
[ cos(q2 - 0.5*pi), -sin(q2 - 0.5*pi), 0, 0.35],
[                0,                 0, 1,    0],
[-sin(q2 - 0.5*pi), -cos(q2 - 0.5*pi), 0,    0],
[                0,                 0, 0,    1]])
(Pdb) T2_3
Matrix([
[cos(q3), -sin(q3), 0, 1.25],
[sin(q3),  cos(q3), 0,    0],
[      0,        0, 1,    0],
[      0,        0, 0,    1]])
(Pdb) T3_4
Matrix([
[ cos(q4), -sin(q4), 0, -0.054],
[       0,        0, 1,    1.5],
[-sin(q4), -cos(q4), 0,      0],
[       0,        0, 0,      1]])
(Pdb) T4_5
Matrix([
[cos(q5), -sin(q5),  0, 0],
[      0,        0, -1, 0],
[sin(q5),  cos(q5),  0, 0],
[      0,        0,  0, 1]])
(Pdb) T5_6
Matrix([
[ cos(q6), -sin(q6), 0, 0],
[       0,        0, 1, 0],
[-sin(q6), -cos(q6), 0, 0],
[       0,        0, 0, 1]])
(Pdb) T6_EE
Matrix([
[1, 0, 0,     0],
[0, 1, 0,     0],
[0, 0, 1, 0.303],
[0, 0, 0,     1]])
```

I created these transforms by providing the DH parameters to a function that returned a sequence of four basic transformations, two rotations and two translations. A function that returns the transformation for this sequence as defined in the literature follows:
```
def tf_matrix(alpha, a, d, q):
    return Matrix([[          cos(q),           -sin(q),           0,             a],
		[sin(q)*cos(alpha), cos(q)*cos(alpha), -sin(alpha), -sin(alpha)*d],
		[sin(q)*sin(alpha), cos(q)*sin(alpha),  cos(alpha),  cos(alpha)*d],
		[                0,                 0,           0,             1]])

```

Finally, a full transform betwen the base_link and gripper_link is generated by multiplying the full set of the previous transforms:

```
(Pdb) T0_EE
Matrix([
[(((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*cos(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*sin(q5))*cos(q6) - ((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) - sin(q1)*cos(q4))*sin(q6), -(((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*cos(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*sin(q5))*sin(q6) - ((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) - sin(q1)*cos(q4))*cos(q6), -((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*sin(q5) + (-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*cos(q5), -0.303*((-sin(q3)*sin(q2 - 0.5*pi)*cos(q1) + cos(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) + sin(q1)*sin(q4))*sin(q5) + 0.303*(-sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q1)*cos(q3))*cos(q5) + 0.054*sin(q3)*sin(q2 - 0.5*pi)*cos(q1) - 1.5*sin(q3)*cos(q1)*cos(q2 - 0.5*pi) - 1.5*sin(q2 - 0.5*pi)*cos(q1)*cos(q3) - 0.054*cos(q1)*cos(q3)*cos(q2 - 0.5*pi) + 1.25*cos(q1)*cos(q2 - 0.5*pi) + 0.35*cos(q1)],
[(((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*cos(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*sin(q5))*cos(q6) - ((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) + cos(q1)*cos(q4))*sin(q6), -(((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*cos(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*sin(q5))*sin(q6) - ((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*sin(q4) + cos(q1)*cos(q4))*cos(q6), -((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*sin(q5) + (-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*cos(q5), -0.303*((-sin(q1)*sin(q3)*sin(q2 - 0.5*pi) + sin(q1)*cos(q3)*cos(q2 - 0.5*pi))*cos(q4) - sin(q4)*cos(q1))*sin(q5) + 0.303*(-sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - sin(q1)*sin(q2 - 0.5*pi)*cos(q3))*cos(q5) + 0.054*sin(q1)*sin(q3)*sin(q2 - 0.5*pi) - 1.5*sin(q1)*sin(q3)*cos(q2 - 0.5*pi) - 1.5*sin(q1)*sin(q2 - 0.5*pi)*cos(q3) - 0.054*sin(q1)*cos(q3)*cos(q2 - 0.5*pi) + 1.25*sin(q1)*cos(q2 - 0.5*pi) + 0.35*sin(q1)],
[                                                                                         ((sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*sin(q5) + (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*cos(q4)*cos(q5))*cos(q6) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q4)*sin(q6),                                                                                          -((sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*sin(q5) + (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*cos(q4)*cos(q5))*sin(q6) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q4)*cos(q6),                                                       (sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*cos(q5) - (-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q5)*cos(q4),                                                                                                       0.303*(sin(q3)*sin(q2 - 0.5*pi) - cos(q3)*cos(q2 - 0.5*pi))*cos(q5) - 0.303*(-sin(q3)*cos(q2 - 0.5*pi) - sin(q2 - 0.5*pi)*cos(q3))*sin(q5)*cos(q4) + 1.5*sin(q3)*sin(q2 - 0.5*pi) + 0.054*sin(q3)*cos(q2 - 0.5*pi) + 0.054*sin(q2 - 0.5*pi)*cos(q3) - 1.25*sin(q2 - 0.5*pi) - 1.5*cos(q3)*cos(q2 - 0.5*pi) + 0.75],
[                                                                                                                                                                                                                                                                                                                 0,                                                                                                                                                                                                                                                                                                                   0,                                                                                                                                                                                            0,                                                                                                                                                                                                                                                                                                                                                                                                                       1]])

```

And here's where you can draw out and show your math for the derivation of your theta angles. 

![alt text][image2]

### Project Implementation

#### 3. Fill in the `IK_server.py` file with properly commented python code for calculating Inverse Kinematics based on previously performed Kinematic Analysis. Your code must guide the robot to successfully complete 8/10 pick and place cycles. Briefly discuss the code you implemented and your results. 


Here I'll talk about the code, what techniques I used, what worked and why, where the implementation might fail and how I might improve it if I were going to pursue this project further.  


And just for fun, another example image:
![alt text][image3]


